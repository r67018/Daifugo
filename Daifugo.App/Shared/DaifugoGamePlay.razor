@using System.Collections.Immutable
@using Daifugo.Lib

<div>
    残り枚数:
    @for (var i = 0; i < PlayerCount; i++)
    {
        var playerIndex = new PlayerIndex(i);
        <span class="mx-2">
            プレイヤー@(i + 1): @_gameState.Hands[playerIndex.Value].Count 枚
        </span>
    }
</div>

<MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.Center" Class="my-2">
    @if (IsGameOver)
    {
        <MudText Typo="Typo.h5" Color="Color.Success">ゲーム終了！</MudText>
    }
    else if (IsUserTurn)
    {
        <MudText Typo="Typo.body2">あなたのターンです</MudText>
    }
    else
    {
        <MudProgressCircular Indeterminate="true" Color="Color.Secondary" Size="Size.Small"/>
        <MudText Typo="Typo.body2">プレイヤー@(CurrentPlayerIndex.Value + 1)が思考中...</MudText>
    }
</MudStack>

<MudStack Row="true" Wrap="Wrap.Wrap" Justify="Justify.Center" Spacing="2">
    @foreach (var card in _gameState.Table.LastOrDefault([]))
    {
        <PlayingCard Card="card" />
    }
</MudStack>


<MudStack Row="true" Wrap="Wrap.Wrap" Justify="Justify.Center" Spacing="2" Class="mt-16">
    @foreach (var card in UsersHand)
    {
        var isSelected = _selectedCards.Contains(card);
        <div @onclick="() => OnToggleCard(card)" style="@(isSelected ? "transform: translateY(-20px);" : "") transition: transform 0.2s; cursor: pointer;">
            <PlayingCard Card="card" />
        </div>
    }
</MudStack>

<MudStack Row="true" Justify="Justify.Center" Class="mt-4">
    <MudButton OnClick="@(() => OnUserAction(new PlayerAction.Play([.._selectedCards])))"
               Disabled="@(!AreSelectedCardsValid || !IsUserTurn)"
               Variant="Variant.Filled" Color="Color.Primary">
        Play
    </MudButton>
    <MudButton OnClick="@(() => OnUserAction(new PlayerAction.Pass()))"
               Disabled="!IsUserTurn"
               Variant="Variant.Outlined" Color="Color.Primary">
        Pass
    </MudButton>
</MudStack>

@* 行動履歴 *@
<div>
    @foreach (var (index, action) in _actionHistory.AsEnumerable().Reverse())
    {
        <MudStack Row="true">
            <p>player @(index.Value + 1): </p>
            @if (action is PlayerAction.Pass)
            {
                <p>Pass</p>
            }
            else if (action is PlayerAction.Play play)
            {
                <p>Play:</p>
                @foreach (var card in play.Cards)
                {
                    <p>@card.Suit.ToSymbol() @card.Rank.ToSymbol()</p>
                }
            }
        </MudStack>
    }
</div>

@code {
    [Parameter]
    public required int PlayerCount { get; set; } = 4;
    [Parameter]
    public required int SimulationCount { get; set; } = 10;
    
    private readonly MonteCarloSolver _solver = new();
    private readonly PlayerIndex _userPlayerIndex = new(0);
    private readonly HashSet<Card> _selectedCards = [];
    private readonly List<(PlayerIndex, PlayerAction)> _actionHistory = [];
    private GameState _gameState;
    
    private ImmutableList<Card> UsersHand => _gameState.Hands[_userPlayerIndex.Value];
    private bool AreSelectedCardsValid => DaifugoGame.IsValidPlay([.._selectedCards], _gameState.Table);
    private PlayerIndex CurrentPlayerIndex => _gameState.PlayerIndex;
    private bool IsUserTurn => _gameState.PlayerIndex == _userPlayerIndex;
    private bool IsGameOver => DaifugoGame.IsGameOver([.._gameState.Hands.Select(h => h.Count)]);

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _gameState = DaifugoHelper.GenerateInitialGameState(PlayerCount);
        // コンピュータのターンを処理
        await _processComputerTurn();
    }

    private void OnToggleCard(Card card)
    {
        if (!_selectedCards.Contains(card) && _selectedCards.Count < 4)
        {
            _selectedCards.Add(card);
        }
        else
        {
            _selectedCards.Remove(card);
        }
    }

    private async Task OnUserAction(PlayerAction action)
    {
        // プレイなのにカードを選択していない場合は無視
        if (action is PlayerAction.Play && _selectedCards.Count == 0) return;
        // 選択したカードが不法な場合は無視
        if (action is PlayerAction.Play play &&
            !DaifugoGame.IsValidPlay(play.Cards, _gameState.Table)) return;
        
        _gameState = DaifugoGame.PlayOneTurn(_gameState, action);
        _selectedCards.Clear();
        _actionHistory.Add((_userPlayerIndex, action));
        // コンピュータのターンを処理
        await _processComputerTurn();
    }
    
    private async Task _processComputerTurn()
    {
        while (!IsUserTurn && !IsGameOver)
        {
            await Task.Delay(100);
            StateHasChanged();
            
            var currentPlayerIndex = _gameState.PlayerIndex;
            var solverInput = new SolverInput(_gameState);
            var bestAction = await Task.Run(() => _solver.FindMostValidPlay(solverInput, SimulationCount));
            _gameState = DaifugoGame.PlayOneTurn(_gameState, bestAction);
            _actionHistory.Add((currentPlayerIndex, bestAction));
            StateHasChanged();
        }
    }
}